# `do` for indented block, inferred in indents outside parens etc.
# `foo(a, b)`, `foo.(a, b)`, `a.foo(b)`, `foo a, b`
# `(a.foo b)`, `(a.foo)(b)` for calling `a.foo`
# `(foo a, b)` => `(foo(a, b))`, `a, b` => `(a, b)`
# operators exist, in the usual case `foo a = b` is `foo(a = b)`
# operators can be words, `is`, `div`, `and`
# foo bar a, b parses as foo(bar(a), b) not foo(bar(a, b)) conflicted on this
# foo bar a, b do c parses as foo(bar(a), b, c)

binary_search(a, k) =
  # indent without do
  for result i = 0
    b = a.size
    while i < b
      # current if else syntax
      if a[mid] < k, i = mid + 1, else: b = mid
    unless i < a.size and a[i] == k, i = -1

binary_search(a, k) =
  for b = a.size, result i = 0
    while i < b
      if a[mid] < k
        i = mid + 1
      \else # complicated what the \ means, basically it allows `else` to output a nested if
        b = mid
    unless i < a.size and a[i] == k, i = -1

assert
  3 == (binary_search [1, 2, 3, 4, 5, 6], 4)
  3 == \binary_search [1, 2, 3, 4, 5, 6], 4 # inline line syntax, allows open calls with operators
  # very pointless and inconsistent with other uses of \
  binary_search([3, 5, 1, 4, 1], 1) == -1

space functional
  permutation(n: Int, r: Int) = product n - r + 1 .. n
  factorial(n: Int) = permutation(n, n)
  combination(n: Int, r: Int) = permutation(n, r) / factorial(r)

space imperative
  factorial(n: Int) =
    x = i = 1
    while i < n, x *= i += 1
    x

  permutation(n: Int, r: Int) =
    for result x = 1, each i = succ n - r .. n
      x |>= *i # this operator is made up but is possible

  combination(n: Int, r: Int) = do for result x = 1, each i in 0..<r do while i < r do x = x * (n - i) / (r - i)

assert
  functional.factorial(5) == imperative.factorial(5) == 120
  functional.permutation(4, 2) == imperative.permutation(4, 2) == 12
  functional.combination(6, 3) == imperative.combination(6, 3) == 20

compare_ignore_case(x: List[String]) = do chain iterate x
  map lower; consecutives 2
  all ((a, b)) => a == b

assert
  compare_ignore_case(spread_list "abcD" "AbCD" "ABCd" "ABCD" "abcd")
  not compare_ignore_case(spread_list " ab CD" "abcd")
  not spread compare_ignore_case, "bcda", "cbad", "dabdab"
