# indented block expressions with do
# `do` for indented block, inferred in indents outside parens etc.
# old kismet path syntax is retained so you can do `foo(a, b)` and `a.foo(b)` and a dot can go between ( and preceding token
# calls can be done like `foo a, b`
# however to call `a.foo` you have to do `(a.foo b)` or `(a.foo)(b)` if i can make that work
# (foo a, b) parses as ~~(foo(a), b)~~ (foo(a, b)), and a, b by itself parses as (a, b)
# operators exist, always have more precedence than open calls, so `foo a = b` is `foo(a = b)`
# operators can be words, `is`, `div`, `and`
# foo bar a, b parses as foo(bar(a), b) not foo(bar(a, b)) conflicted on this
# foo bar a, b do c parses as foo(bar(a), b, c)

# maybe does or => or ->
binary_search(a, k) = # indent without do
  # functions can be generic, which makes them gradually typed
  for result i = 0
    b = a.size # the type of a is checked to see if .size can be called and how
    while i < b
      if a[mid] < k, i = mid + 1, else: b = mid # current if else syntax
    unless i < a.size and a[i] == k, i = -1

binary_search(a, k) =
  for b = a.size, result i = 0
    while i < b
      if a[mid] < k
        i = mid + 1
      \else # complicated what the \ means
        b = mid
    unless i < a.size and a[i] == k, i = -1

assert
  3 == \binary_search [1, 2, 3, 4, 5, 6], 4 # inline line syntax, allows open calls with operators
  # very pointless and inconsistent with other uses of \
  binary_search([3, 5, 1, 4, 1], 1) == -1

space functional
  permutation(n: Int, r: Int) = \product n - r + 1 .. n
  factorial(n: Int) = permutation(n, n)
  combination(n: Int, r: Int) = permutation(n, r) / factorial(r)

space imperative
  factorial(n: Int) =
    x = i = 1
    while i < n, x *= i += 1
    x

  permutation(n: Int, r: Int) =
    for result x = 1, each i = succ n - r .. n
      x |>= * i # this operator is made up but is possible

  combination(n: Int, r: Int) = do for result x = 1, each i in 0..<r do while i < r do x = x * (n - i) / (r - i)

assert
  functional.factorial(5) == imperative.factorial(5) == 120
  functional.permutation(4, 2) == imperative.permutation(4, 2) == 12
  functional.combination(6, 3) == imperative.combination(6, 3) == 20

compare_ignore_case(x: List[String]) = do chain iterate x
  map lower; consecutives 2
  all ((a, b)) => a == b

assert
  compare_ignore_case(spread_list "abcD" "AbCD" "ABCd" "ABCD" "abcd")
  not compare_ignore_case(spread_list " ab CD" "abcd")
  not spread compare_ignore_case, "bcda", "cbad", "dabdab"
